# Lattice graphics {#lattice}

```{r setup, include=FALSE}
source("global_parameters.R")
knitr::opts_chunk$set(fig.width=fig.width_lattice, fig.height=fig.height_lattice)
```

The `lattice` package provides an alternative to the base R graphics system; it is an implementation of the ideas developed and implemented by Rick Becker and Bill Cleveland in the Trellis graphics system for the S language. Trellis displays were developed as a framework to easily display of the relationship between a dependent variable and multiple factors. 

The best introduction to `lattice` graphics is the book by @Sarkar2008, the author of `lattice`: Lattice: Multivariate Data Visualization with R. The `lattice` package documentation, available [here](https://cran.r-project.org/web/packages/lattice/lattice.pdf), is a good reference.

The following articles also contain useful info:

- [Some notes on lattice](http://www.ci.tuwien.ac.at/Conferences/DSC-2003/Proceedings/Sarkar.pdf) [@Sarkar2003] 
- [R Lattice Graphics](http://www.ci.tuwien.ac.at/Conferences/DSC-2001/Proceedings/Murrell.pdf) [@Murrell2001] 
- [Lattice, an implementation of Trellis graphics in R](https://cran.r-project.org/doc/Rnews/Rnews_2002-2.pdf) [@Sarkar2002]

Because `lattice` is mostly compatible with the Trellis graphics system in S-Plus, the following documents written for Trellis also provide a good introduction to `lattice` and to the concept of trellis displays:

- S-PLUS Trellis Graphics User's Manual [@BeckerAndCleveland2002]
- A Tour of Trellis Graphics [@BeckerEtAl1996]
- The Visual Design and Control of Trellis Display [@BeckerEtAl1996b]
- Trellis Display: Modelling Data from Designed Experiments [@ClevelandAndFuentes1997]

## Overview of lattice graphics

  Function
  ---------
  `xyplot` 
  `barchart` 
  `dotplot` 
  `stripplot` 
  ` bwplot` 

Table: (\#tab:latticefunctions) Lattice graphics functions.

## Introduction to model formulae and multi-panel conditioning

We will use the `rats_trellis.txt` dataset to illustrate how conditioning based on one or more factors work in lattice. The dataset contains data from a fictitious experiment in which a researcher is investigating the effects of alcohol and drug consumption on social interactions in rats. The researcher studies two species of rats (Kalamani vs Yuppy), each rat has been observed in four experimental conditions, given by the combination of two factors: administration of drug (Drug vs No-Drug) and administration of alcohol (Al vs No-Al). The dependent variable is the number of social interactions observed in each of the four conditions. We'll read in the data first:

```{r}
dats = read.table("datasets/rats_trellis.txt", header=TRUE)
dats$subj = as.factor(dats$subj)
head(dats)
```

we'll start visualising the data along one dimension, the species. This is a single dimension, that can be easily handled by the base graphics system, but can be equally well displayed with lattice. Since the high level lattice plotting functions require the data to be entered as a dataframe, we'll use the `aggregate` function to get a dataframe with the mean values of `socialint`, the dependent variable, on the basis of the species:

```{r}
bySpec = aggregate(dats$socialint, 
                    by=list(species=dats$species), FUN=mean)
names(bySpec)[which(names(bySpec)=="x")] = "socialint"
bySpec
```

lattice uses a model formula syntax, you give it a dataframe, and specify how you want a variable to be displayed along the dimensions of one or more factors. In our case, we want `socialint ~ species` (you could read the `~` "as explained by species"), the barchart can be produced with the code below, and is displayed in Figure \@ref(fig:ratstrellis1)

```{r ratstrellis1, fig.cap="Social interactions by species"}
library(lattice)
##trellis.device() #optional
pl1 = barchart(socialint ~ species, data=bySpec)
print(pl1)
```

Now suppose we want to visualise the relationship between `socialint` and `species` on the basis of alcohol administration. In lattice there are two ways of doing it, one is by the use of a "grouping" factor, this yields a display similar to the `barplot` function. The second way is by multi-panel factor conditioning. The advantage of multi-panel conditioning, as we will see soon, is that it can be extended to an unlimited number of factors. Let's start with the first solution, in which we use a grouping factor. First we create a suitable dataframe:
```{r}
bySpecAl = aggregate(dats$socialint, 
                      by=list(species=dats$species, 
                          alcohol=dats$alcohol), FUN=mean)
names(bySpecAl)[which(names(bySpecAl)=="x")] = "socialint"
```

then we produce the barchart which you can see in Figure \@ref(fig:ratstrellis2)

```{r ratstrellis2, fig.cap="Social interactions by species and alcohol administration with grouping factor"}
pl2 = barchart(socialint ~ species, groups=alcohol, 
                 data=bySpecAl, auto.key=TRUE)
print(pl2)
```

the grouping factor is given by the `groups` argument, note also that we have set `auto.key` to `TRUE` in order to automatically add a legend.

the second way of doing the graph is by multi-panel conditioning, we achieve this by putting alcohol as a conditioning factor with the `|` syntax.
```{r ratstrellis3, fig.cap="Social Interactions by species and alcohol administration with multi-panel conditioning"}
pl3 = barchart(socialint ~ species | alcohol, data=bySpecAl)
print(pl3)
```

the resulting graph is displayed in Figure \@ref(fig:ratstrellis3). We could have swapped `species` for `alcohol` as the conditioning factor, which way gives the more effective display depends from case to case, and it's up to the user to decide. Finally we'll consider the case in which all factors are included in the display, this cannot be easily achieved with base R graphics, but it is easily done in lattice, we just add `drug` to the conditioning factors (Figure \@ref(fig:ratstrellis4))

```{r ratstrellis4, fig.cap="Social interactions by species, alcohol administration and drug with multi-panel conditioning", fig.width=fig.width_lattice*2, fig.height=fig.height_lattice*2}
bySpecAlDrug = aggregate(dats$socialint, 
                          by=list(species=dats$species, 
                          alcohol=dats$alcohol, drug=dats$drug), 
                          FUN=mean)
names(bySpecAlDrug)[which(names(bySpecAlDrug)=="x")] = "socialint"
pl4 = barchart(socialint ~ species | alcohol * drug, 
                data=bySpecAlDrug)
print(pl4)
```

we could have used a grouping variable also in this case rather than using two conditioning factors (Figure \@ref(fig:ratstrellis5))

```{r ratstrellis5, fig.cap="Social interactions by species, alcohol administration and drug with grouping factor"}
pl5 = barchart(socialint ~ species | alcohol, 
                groups=drug, data=bySpecAlDrug,
                auto.key=TRUE)
print(pl5)
```

again what is the best display is up to the user to decide and depends from case to case.

## `barchart`

We will look at an example of a barchart display of a dependent measure conditional on three factors. The dataset `line_matching.txt` contains data on an imaginary experiment in which a psychophysicist wants to measure the accuracy of matching the length of a segment for three groups of people (Gr. 1, Gr. 2, Gr. 3) for segments of four different lengths (L1, L2, L3, L4). The third factor the psychophysicist is interested in is whether matching accuracy changes depending on the colour (blue vs red) of the segment to be matched, he measures this as a within subjects factor. The matching accuracy is measured as the error, or displacement (positive or negative) from the actual segment length. The dataset contains the mean values for the three groups. Below is the code for producing the barchart, the resulting plot can be seen in Figure \@ref(fig:linematching):
```{r linematching, fig.cap="Line matching barchart", fig.width=fig.width_lattice*2, fig.height=fig.height_lattice*2}
dats = read.table("datasets/line_matching.txt", header=TRUE)
#trellis.device()
oldpar = trellis.par.get("superpose.polygon")
trellis.par.set(superpose.polygon = 
list(col = c("darkslateblue", "indianred")))
myGraph = barchart(error ~ length | group, groups=color, 
           data=dats, origin=0, ylab="Error (cm)", 
           xlab="Segment Length", 
           auto.key=TRUE, as.table=TRUE)
print(myGraph)
trellis.par.set(superpose.polygon = oldpar)
```

We're showing the bars for the two levels of the "color" factor side by side in the same panel, this is done by using the factor in the `groups` argument. A different display could have been achieved by putting the "color" factor as an additional conditioning variable:

```{r fig.show="hide"}
barchart(error ~ length | group * color, 
         data=dats, origin=0, ylab="Error (cm)",
         xlab="Segment Length", 
         auto.key=TRUE, as.table=TRUE)

```
in this case the bars for each level of the factor would have been drawn in different panels (the number of panels would have doubled).

The fill color for the bars can be modified changing the color option for `superpose.polygon`. 

The great thing about trellis graphics is that they allow you to display the relationship between a dependent variable and multiple factors seamlessly. Suppose that, continuing the above example, the psychophysician has tested the line matching accuracy on the three groups both before and after a period of visuo-motor training. The dataset containing the data with this new factor is in the file `line_matching_training.txt`. We just need to add the new factor `session` (pre-training vs post-training) to the conditioning variables to obtain the new plot. The modified call to the `barchart` function is shown below and the resulting graph can be seen in Figure \@ref(fig:linematchingtraining).

```{r linematchingtraining, fig.cap="Line matching training barchart", fig.width=fig.width_lattice*2, fig.height=fig.height_lattice*2}
dats = read.table("datasets/line_matching_training.txt",
                  header=TRUE)
myGraph = barchart(error ~ length | group * session, groups=color, 
                    data=dats, origin=0, ylab="Error (cm)", 
                    xlab="Segment Length", 
                    auto.key=TRUE, as.table=TRUE)
print(myGraph)
```

## Histograms

```{r latticehist1, fig.caption="Histogram."}
data(iris)
p = histogram(~Sepal.Length, data=iris)
print(p)
```

```{r latticehist2, fig.caption="Histogram with panel conditioning.", fig.width=fig.width_lattice*2, fig.height=fig.height_lattice*2}
p = histogram(~Sepal.Length|Species, data=iris)
print(p)
```

## Interaction plots

Example of interaction plot with 3 factors:

```{r latticeintplot, fig.cap="Interaction plot with three factors", fig.width=fig.width_lattice*2, fig.height=fig.height_lattice*2}
dat = read.table("datasets/lattice_int_plot_data.csv", sep=",", header=T)
dat$time = factor(dat$time); dat$cond=factor(dat$cond); dat$id = factor(dat$id)
p = bwplot(prop~time | id, groups=cond, data=dat,
           panel='panel.superpose', panel.groups='panel.linejoin',
           auto.key=list(points=FALSE, lines=TRUE, space='top'),
           scales=list(cex=.8),
           ylab='Proportion', xlab='Time (ms)', as.table=TRUE)
print(p)
```

## Customizing lattice graphics {#customizingtrellis}

### Textual elements

#### Strip labels

The labels of the panels strips are the names of the levels of the conditioning factor variable. To change their labels you can pass the `factor.levels` argument to the `strip.custom` function:

```{r strip1, fig.cap="Custom strip labels"}
x = rnorm(20)
y = rnorm(20)
treat = factor(rep(c("A", "B"), each=10))
xyplot(y~x|treat, strip=strip.custom(factor.levels=c("Group A", "Group B")))
```

Alternatively, you change the names for the factor levels:
```{r}
levels(treat) = c("Group A", "Group B")
```

if you have more than one conditioning factor you can customize the strip labels for each by passing a custom strip function. `which.given` specifies the conditioning
variable that the strip corresponds to:

```{r strip2, fig.cap="Custom strip labels with two conditioning factors", fig.width=fig.width_lattice*2, fig.height=fig.height_lattice*2}
cnd = factor(rep(c("I", "II"), 10))

customstrip = function(which.given, ..., factor.levels){
    levs = if (which.given==1){
        c("Group A", "Group B")
    } else if  (which.given==2){
        c("Cnd. I", "Cnd. II")
    }
    strip.default(which.given, ..., factor.levels = levs)
}
xyplot(y~x | treat + cnd, strip=customstrip, as.table=TRUE)
```


### Log axis with pretty tickmarks

The procedure to get a log axis with pretty tickmarks in lattice is a bit involved. We'll only cover the log base 10 case here. The first step is to define a function that returns the tick locations:

```{r}
log10Ticks = function(lim, onlyMajor=FALSE){
    minPow = floor(log10(lim[1]))
    maxPow = ceiling(log10(lim[2]))
    powSeq = seq(minPow, maxPow)
    majTicks = 10^powSeq
    minTicks = numeric()
    for (i in 1:length(majTicks)){
        bb = (1:10)/10;
        minTicks = c(minTicks, (bb*10^powSeq[i]))
    }
    if (onlyMajor==TRUE){
        axSeq = majTicks
    } else {
        axSeq = minTicks
    }
    axSeq = axSeq[lim[1] <= axSeq & axSeq <= lim[2]]
    return(axSeq)
}
```

by default the function returns both the major (e.g. 1, 10, 100, etc...) and the minor (e.g. 2,3,4,...20,30,40, etc...) tick locations, but returns only the major tick locations if `onlyMajor=TRUE`.
This function will be used by the `yscale.components.log10` function below. This function will be passed as the `yscale.components` argument in the `xyplot` call that generates the graph. The `yscale.components.log10` function will return a list specifying all parameters of the y axis. To simplify this process the function calls the `yscale.components.default` function to retrieve the default parameters, and then simply modifies some of these parameters to draw the pretty log axis:

```{r}
#the function is automatically passed the limits of the panel as an argument
yscale.components.log10 = function(lim, ...){
    #retrieve default parameters
    ans = yscale.components.default(lim = lim, ...)
    #compute major and minor tick locations
    tick.at = log10Ticks(10^lim, onlyMajor=FALSE)
    #compute major tick locations only
    tick.at.major = log10Ticks(10^lim, onlyMajor=TRUE)
    #which are the major ticks?
    major = tick.at %in% tick.at.major
    #where the ticks should be position
    ans$left$ticks$at = log10(tick.at)
    #set tick length, depending on whether minor or major
    ans$left$ticks$tck = ifelse(major, 1.5, 0.75)
    #labels location
    ans$left$labels$at = log10(tick.at)
    #set tick labels
    ans$left$labels$labels = as.character(tick.at)
    #set minor tick labels as empty
    ans$left$labels$labels[!major] = "" 
    ans$left$labels$check.overlap = FALSE
    return(ans)
}
```

once the `yscale.components.log10` function is ready, we can use it in the call to `xyplot`, note that we also need to set the y scale to log10 in the `scales` argument:

```{r fig.cap="Log axis with pretty tickmarks"}
x = c("cnd1", "cnd2")
y = c(0.4, 80)
dat = data.frame(x=x, y=y)
xyplot(y~x, data=dat,
       scales=list(y=list(log=10)),
       yscale.components = yscale.components.log10)
```




## Writing panel functions {#trellispanel}

### Combining panel functions

Rather than writing a new panel function from scratch, often you just want to add some elements to a plot, for example a regression line, or error bars. The easiest and probably best way to do this is writing a panel function that combines two standard panel functions. There is a number of predefined panel functions (see `?panel.functions`) that can be used to add lines, grids etc..., to a scatterplot, barchart or other higher level plotting lattice function.

We will start with a very simple example, adding a horizontal line at a fixed height in a dotplot. The `line_matching` dataset described in the barchart example, can be visualised very well also through a dotplot (Figure \@ref(fig:lmatchdotplot))

```{r lmatchdotplot, fig.cap="Dotplot of the line matching dataset", fig.width=fig.width_lattice*2, fig.height=fig.height_lattice*2}
oldpar = trellis.par.get("superpose.symbol")
trellis.par.set(superpose.symbol = 
                list(col = c("darkslateblue", 
                "indianred"), pch=19))
dotplot(error ~ length | group, groups=color, 
        data=dats, origin=0, ylab="Error (cm)", 
        xlab="Segment Length", auto.key=TRUE, 
        aspect=1, as.table=TRUE)
```

however, since the data represent positive or negative displacements from  zero, it would be nice to add a horizontal line passing at zero. In order to have this, we will write a panel function that combines the `panel.dotplot` function with the `panel.abline` function that we'll use to add the horizontal line:

```{r}
panel.hRefDotplot = function(x, y, ref=NULL, ...){
panel.dotplot(x, y, ...)
panel.abline(h=ref, ...)
}
```

our new `panel.hRefDotplot` panel function accepts three arguments, `x` and `y`, which are the "standard" arguments given by the higher level plotting functions like `dotplot` to panel functions to specify the data to draw. The third argument represents the position at which to draw the horizontal line of reference for the data, we want it to be zero in this case, but passing the argument as a variable rather than hard-coding the value into the panel function will allow us to recycle this panel function in case we want the horizontal reference line drawn at some other points in the future. Besides these arguments, our panel function accepts also an undefined number of other arguments, which are designated by the `...` notation. These are usually graphics parameters that can be specified in the high level plotting function. The contents of our `panel.hRefDotplot` function are very simple, we call first `panel.dotplot` to draw the standard dotplot, and then we call `panel.abline` giving it the value of `ref` to draw the horizontal line in each panel. The actual plot is done by calling the high level `dotplot` function specifying `panel.hRefDotplot` as the panel function to use:

```{r lmatchdotplotref, fig.cap="Dotplot of the line matching dataset, with an horizontal reference line", fig.width=fig.width_lattice*2, fig.height=fig.height_lattice*2}
dotplot(error ~ length | group, groups=color, 
        data=dats, origin=0, ylab="Error (cm)", 
        xlab="Segment Length", auto.key=TRUE, aspect=1, 
        as.table=TRUE, ref=0, panel=panel.hRefDotplot)
```

note the last line of the call, first we're telling `dotplot` to use our `hRefDotplot` function to do the plotting by specifying the `panel` argument, second we're specifying another argument, `ref` in the call, this is not a standard argument, but it will be automatically passed to our panel function to decide at which height to draw the horizontal line. The resulting plot can be visualised in Figure \@ref(fig:lmatchdotplotref).
